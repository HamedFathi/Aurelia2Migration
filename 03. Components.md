# :black_nib: Components

## :open_book: The Root Component

The root of any Aurelia application is a `single` component, which contains everything within the application, actually, the root component.

### :heart: Aurelia 1

```html
<!-- View -->
<!-- src/app.html -->

<require from="./styles.css"></require>
<require from="./nav-bar.html"></require>
<template>
    <h1>${message}</h1>
</template>
```

```ts
// ViewModel
// src/app(.js|.ts)

export class App {
    constructor() {
        this.message = 'Hello World!';
    }
}
```

* To import any style, component or etc you should use `require`.
* Wrapping the whole HTML content via `template` is necessary.


### :gem: Aurelia 2

To import any style, component or etc you should use import. An alternative to require in version 1. By default, the components you create aren't global. What that means is that you can't use a component within another component, unless that component has been imported.

```html
<!-- View -->
<!-- src/my-app.html -->

<import from="./welcome"></import>
<import from="./about.html"></import>
<div class="message">${message}</div>
```
```ts
// ViewModel
// src/my-app(.js|.ts)

export class MyApp {
  public message = 'Hello World!';
}
```
```css
/* Style */
/* src/my-app.css */

nav {
  background: #eee;
  display: flex;
}
a {
  padding: 10px;
  text-decoration: none;
  color: black;
}
a:hover {
  background-color: darkgray;
}
.load-active {
  background-color: lightgray;
}
```

* To import any style, component or etc you should use `import`. An alternative to `require` in version 1. By default, the components you create aren't global. What that means is that you can't use a component within another component, unless that component has been imported.

```html
<import from="./name-tag">

<h2>${message} <name-tag name.bind="to"></name-tag>!</h2>
<button click.trigger="leave()">Leave</button>
```

* Wrapping the whole HTML content via `template` is `optional`.

## :open_book: The Component Life-cycle

Every component instance has a life-cycle that you can tap into. This makes it easy for you to perform various actions at particular times.

### :heart: Aurelia 1

| Name | Description |
|------|-------------|
|constructor|The Constructor method is used for initializing an object created with a class. This method is called first.|
|created|This is called once the view and view-model are created and connected to the controller.|
|bind|At this point of time, the binding has started.|
|attached|The Attached method is invoked once the component is attached to the DOM.|
|detached|This method is opposite to attached. It is invoked when the component is removed from the DOM.|
|unbind|The last life-cycle method is unbind. It is called when the component is unbound.|

### :gem: Aurelia 2

|Name|Description|Aurelia 1|Asyncable|
|----|-----------|---------|---------|
|constructor|When the framework instantiates a component, it calls your class's constructor, just like any JavaScript class.|constructor|**✗**|
|create|The go-to hook for contextual dynamic composition. It runs just after the constructor and can be treated like a late interceptor for the @customElement decorator / CustomElement.define api|**✗**|**✗**|
|beforeCompile|Allows you to add contextual DI registrations (to controller.context) to influence which resources are resolved when the template is compiled.|@processContent|**✗**|
|afterCompile|The hook is a good place to contextually influence the way child components are constructed and rendered. It runs synchronously after the definition is compiled|**✗**|**✗**|
|afterCompileChildren|The hook is the last hook that can be considered part of "construction". It is called (synchronously) after this component is hydrated, which includes resolving, compiling and hydrating child components.|created|**✗**|
|beforeBind|The framework will invoke it when it has begun binding values to your bindable properties.|bind|**✓**|
|afterBind|The framework will invoke it when it has fully bound your component, including its children.|**✗**|**✓**|
|beforeAttach|The framework will invoke it when it is about to attach your HTML element to the document. In terms of the component hierarchy, the beforeAttach hooks execute top-down. However, nothing is mounted to the DOM just yet.|**✗**|**✓**|
|afterAttach|The framework will invoke it when it has fully attached your HTML element to the document, along with its children.|attached|**✓**|
|beforeDetach|The framework will invoke it when it is about to remove your HTML element from the document.|**✗**|**✓**|
|caching|The framework will invoke it immediately after the DOM nodes are unmounted. This is an advanced hook mostly useful for clean up of resources and references to views you own before they are put into the cache by the framework.|**✗**|?|
|afterDetach|The framework will invoke it when it has fully removed your HTML element from the document.|detached|**✓**|
|beforeUnbind|The framework will invoke it when it has begun disconnecting bindings from your component.|unbind|**✓**|
|afterUnbind|The framework will invoke it when it has fully disconnected bindings from your component.|**✗**|**✓**|
|afterUnbindChildren|?|**✗**|**✓**|
|dispose|?|**✗**|?|

`beforeCompile` and `@processContent` are not exactly the same, they just happen to have the same timing. But we'll add a `@processContent` in for backwards compat, and it will be using the `beforeCompile` hook.

Aurelia 1 has a restriction and the community made an [afterAttached](https://github.com/aurelia-ui-toolkits/aurelia-after-attached-plugin) plugin that is called after all child components are attached, and after all two-way bindings have completed. The good news is the `afterAttach` lifecycle in version 2 covers this scenario too.

**Which life-cycle hooks are most used?**

Such cases can be summarized.

|Name|When using it|
|----|-------------|
|beforeBind|Fetch data (working with API services & Ajax calls), initialize data/subscriptions.|
|afterBind|Any work that relies on fromView/twoWay binding data coming from children, Defining router hooks.|
|afterAttach|Use anything (like third-party libraries) that touches the DOM.|
|beforeUnbind|Persisting data.|
|afterUnbind|Cleanup data/subscriptions.|